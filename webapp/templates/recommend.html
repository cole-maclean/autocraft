<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>StarCraftII Build Order Recommender</title>

    <style>

  .node circle {
    fill: #fff;
    stroke: steelblue;
    stroke-width: 3px;
  }

  .node text { font: 12px sans-serif; }

  .link {
    fill: none;
    stroke: #ccc;
    stroke-width: 2px;
  }
  
    </style>

  </head>

  <body>
  Select your race and enemy race. </br>
  Build suggestions will be given when they are clicked on, and custom builds can be made by inputting the desired unit and clicking on the custom node to insert that unit into the build order.


<!-- load the d3.js library --> 
<script src="http://d3js.org/d3.v3.min.js"></script>
  
<script>

var treeData = {{ tree_data| tojson | safe }};

var race_data = ["Terran", "Protoss", "Zerg"];
var input_div = d3.select('body').append('div')


var friendly_race = input_div.append('select')
    .attr('class','friendly_race')

var enemy_race = input_div.append('select')
    .attr('class','enemy_race')

var friendly_options = friendly_race
  .selectAll('option')
  .data(race_data).enter()
  .append('option')
    .text(function (d) { return d; });

var enemy_options = enemy_race
  .selectAll('option')
  .data(race_data).enter()
  .append('option')
    .text(function (d) { return d; });

input_div.append('input')
    .attr('type','text')
    .attr('name','textInput')
    .attr('value','Custom Build')


function getDepth(obj) {
    var depth = 0;
    if (obj.children) {
        obj.children.forEach(function (d) {
            var tmpDepth = getDepth(d)
            if (tmpDepth > depth) {
                depth = tmpDepth
            }
        })
    }
    return 1 + depth
}

var depth = getDepth(treeData[0]);

// ************** Generate the tree diagram  *****************
var margin = {top: 40, right: 40, bottom: 20, left: 40},
  width = depth*250 - margin.right - margin.left,
  height = depth*250 - margin.top - margin.bottom;
  
var i = 0;

var tree = d3.layout.tree()
  .size([height/2, width/2]);

var diagonal = d3.svg.diagonal()
  .projection(function(d) { return [d.x, d.y]; });

var main_svg = d3.select("body").append("svg")
  .attr("width", width + margin.right + margin.left)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var friendly_svg = main_svg.append("svg")
  .attr("width", width + margin.right + margin.left)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

var enemy_svg = main_svg.append("svg")
  .attr("width", width + margin.right + margin.left)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform", "translate(" + (margin.left + width/2) + "," + margin.top + ")");
  
update(treeData[0],friendly_svg);
update(treeData[1],enemy_svg);

function update(source,player_svg) {

  // Compute the new tree layout.
  var nodes = tree.nodes(source).reverse(),
    links = tree.links(nodes);

  // Normalize for fixed-depth.
  nodes.forEach(function(d) { d.y = d.depth * 100; });

  // Declare the nodes…
  var node = player_svg.selectAll("g.node")
    .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter the nodes.
  var nodeEnter = node.enter().append("g")
    .attr("class", "node")
    .attr("transform", function(d) { 
      return "translate(" + d.x + "," + d.y + ")"; });

  nodeEnter.append("circle")
    .attr("r", 10)
    .style("fill", "#fff");

  nodeEnter.append("text")
    .attr("y", function(d) { 
      return d.children || d._children ? -18 : 18; })
    .attr("dy", ".35em")
    .attr("text-anchor", "middle")
    .text(function(d) { return d.name; })
    .style("fill-opacity", 1);

  // Declare the links…
  var link = player_svg.selectAll("path.link")
    .data(links, function(d) { return d.target.id; });

  // Enter the links.
  link.enter().insert("path", "g")
    .attr("class", "link")
    .attr("d", diagonal);

}

</script>
  
  </body>
</html>